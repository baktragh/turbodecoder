package turbodecoder.decoder;

import turbodecoder.decoder.pulse.PulseDecoder;
import turbodecoder.decoder.pulse.WavePulseDecoder;
import turbodecoder.decoder.pulse.AudioPulseDecoder;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ItemEvent;
import java.io.File;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import javax.swing.*;
import turbodecoder.DialogManager;
import turbodecoder.ParallelGUIUpdater;
import turbodecoder.TurboDecoder;
import turbodecoder.UIPersistor;
import turbodecoder.Utils;
import turbodecoder.WaveFileFilter;

/**
 *
 * @author  
 */
public class DecoderFrame extends javax.swing.JFrame implements DecoderLog, UIPersistor {

    private final WavePulseDecoder waveDecoder;
    private final AudioPulseDecoder audioDecoder;
    private PulseDecoder decoder;
    private final JComponent[] decodingInvocationComponents;
    private final JComponent[] decodingCancelationComponents;
    private Thread decodingThread;
    private final String[] impulseStrings = {"|", "/", "-", "\\"};
    private int impulsePhase = 0;
    private final Object decoderSyncronizer = new Object();
    private DecoderLogModel logModel;

    private Font[] logFonts;
    private static final int LOG_FONT_NORMAL = 0;
    private static final int LOG_FONT_MEDIUM = 1;
    private static final int LOG_FONT_LARGE = 2;
    private static final int LOG_FONT_EXTRA_LARGE = 3;

    /**
     * Creates new form DecoderFrame
     */
    public DecoderFrame() {

        initLogModel();
        initComponents();
        initLogFonts();
        restoreDefaults();
        handleComponentDependencies();

        waveDecoder = new WavePulseDecoder();
        audioDecoder = new AudioPulseDecoder();
        decoder = null;

        decodingInvocationComponents = new JComponent[]{
            jbtDecode,
            jbtDecodeMultiple,
            jslNavigation,
            jtfSample,
            jbtJump,
            jbtDetach,
            jcoDecoders,
            pGeneralSettingsCover,
            jcbMonitorMode,};

        decodingCancelationComponents = new JComponent[]{jbtStop};
        setIconImage(new ImageIcon(getClass().getResource("/turbodecoder/resources/td_winicon.png")).getImage());

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        fcDecodeInput = new javax.swing.JFileChooser();
        fcDecodeOutput = new javax.swing.JFileChooser();
        pFiles = new javax.swing.JPanel();
        jlbWave = new javax.swing.JLabel();
        jtfWaveFile = new javax.swing.JTextField();
        jbtBrowseWave = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jtfOutDir = new javax.swing.JTextField();
        jbtBrowseDir = new javax.swing.JButton();
        pInputParams = new javax.swing.JPanel();
        jcoSignalSource = new javax.swing.JComboBox<>();
        jlbSourceChannel = new javax.swing.JLabel();
        jcoSourceChannel = new javax.swing.JComboBox<>();
        jlbSampleRate = new javax.swing.JLabel();
        jcoSampleRate = new javax.swing.JComboBox<>();
        jlbBits = new javax.swing.JLabel();
        jcoBitsPerSample = new javax.swing.JComboBox<>();
        pAttachDetach = new javax.swing.JPanel();
        jbtAttach = new javax.swing.JButton();
        jbtDetach = new javax.swing.JButton();
        jlbSignalSource = new javax.swing.JLabel();
        pDecoding = new javax.swing.JPanel();
        pNav = new javax.swing.JPanel();
        jslNavigation = new javax.swing.JSlider();
        jtfSample = new javax.swing.JTextField();
        jbtJump = new javax.swing.JButton();
        pDeco = new javax.swing.JPanel();
        jlbDecoder = new javax.swing.JLabel();
        jcoDecoders = new javax.swing.JComboBox<>();
        jPanel2 = new javax.swing.JPanel();
        jbtDecode = new javax.swing.JButton();
        filler1 = new javax.swing.Box.Filler(new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 0), new java.awt.Dimension(4, 0));
        jbtDecodeMultiple = new javax.swing.JButton();
        filler2 = new javax.swing.Box.Filler(new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 0), new java.awt.Dimension(4, 0));
        jbtStop = new javax.swing.JButton();
        jcbMonitorMode = new javax.swing.JCheckBox();
        jlbImpulse = new javax.swing.JLabel();
        pControls = new javax.swing.JPanel();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        pLog = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jlsMessages = new javax.swing.JList<>();
        jPanel1 = new javax.swing.JPanel();
        btnClearLog = new javax.swing.JButton();
        jbtCopyToClipboard = new javax.swing.JButton();
        jspGeneralSettings = new javax.swing.JScrollPane();
        pGeneralSettingsCover = new javax.swing.JPanel();
        pGeneralSettings = new javax.swing.JPanel();
        jcbPrependSampleNumber = new javax.swing.JCheckBox();
        jcbIgnoreBadChecksums = new javax.swing.JCheckBox();
        jcbPreferAdaptiveTransferSpeedDetection = new javax.swing.JCheckBox();
        jcbVerboseMessages = new javax.swing.JCheckBox();
        jLabel1 = new javax.swing.JLabel();
        jcbFontSize = new javax.swing.JComboBox<>();
        pMonitorModeSettings = new javax.swing.JPanel();
        jcbMonitorSaveAllBytes = new javax.swing.JCheckBox();
        filler3 = new javax.swing.Box.Filler(new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 32767));
        pDSP = new javax.swing.JPanel();
        jcbBlockDCOffset = new javax.swing.JCheckBox();
        jspSchmitt = new javax.swing.JSpinner();
        jLabel3 = new javax.swing.JLabel();
        jspOtherSettings = new javax.swing.JScrollPane();
        pOtherSettingsCover = new javax.swing.JPanel();
        filler4 = new javax.swing.Box.Filler(new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 32767));
        pTurbo2000SuperTurbo = new javax.swing.JPanel();
        jcbCsTurboSaveHeaderToExtraFile = new javax.swing.JCheckBox();
        jcbCsTurboAlwaysSaveAsBinaryFile = new javax.swing.JCheckBox();
        pASTSettings = new javax.swing.JPanel();
        jlbASTFormat = new javax.swing.JLabel();
        jcoASTFormat = new javax.swing.JComboBox<>();
        pLowerSilesiaTurbo2000Settings = new javax.swing.JPanel();
        jlbLowerSilesiaTurbo2000Format = new javax.swing.JLabel();
        jcoLowerSilesiaTurbo2000Format = new javax.swing.JComboBox<>();
        pKSOTurbo2000Settings = new javax.swing.JPanel();
        jlbKSOTurbo2000Format = new javax.swing.JLabel();
        jcoKSOTurbo2000Format = new javax.swing.JComboBox<>();
        pTurboROMSettings = new javax.swing.JPanel();
        jlbTurboROMFormat = new javax.swing.JLabel();
        jcoTurboROMFormat = new javax.swing.JComboBox<>();
        jMenuBar1 = new javax.swing.JMenuBar();
        jmFile = new javax.swing.JMenu();
        jmiExit = new javax.swing.JMenuItem();
        jmHelp = new javax.swing.JMenu();
        jmiAbout = new javax.swing.JMenuItem();

        fcDecodeInput.setFileFilter(new WaveFileFilter()
        );

        fcDecodeOutput.setDialogType(javax.swing.JFileChooser.SAVE_DIALOG);
        fcDecodeOutput.setFileSelectionMode(javax.swing.JFileChooser.DIRECTORIES_ONLY);

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle(TurboDecoder.getInstance().getVersionString());
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                on_close(evt);
            }
        });
        getContentPane().setLayout(new java.awt.BorderLayout(0, 4));

        pFiles.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Input and output"));
        pFiles.setLayout(new java.awt.GridBagLayout());

        jlbWave.setText("WAVE file:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pFiles.add(jlbWave, gridBagConstraints);

        jtfWaveFile.setColumns(32);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 4);
        pFiles.add(jtfWaveFile, gridBagConstraints);

        jbtBrowseWave.setMnemonic('b');
        jbtBrowseWave.setText("Browse");
        jbtBrowseWave.setMargin(new java.awt.Insets(2, 2, 2, 2));
        jbtBrowseWave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtBrowseWaveActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        pFiles.add(jbtBrowseWave, gridBagConstraints);

        jLabel2.setText("Output directory:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pFiles.add(jLabel2, gridBagConstraints);

        jtfOutDir.setColumns(32);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 4);
        pFiles.add(jtfOutDir, gridBagConstraints);

        jbtBrowseDir.setMnemonic('o');
        jbtBrowseDir.setText("Browse");
        jbtBrowseDir.setMargin(new java.awt.Insets(2, 2, 2, 2));
        jbtBrowseDir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtBrowseDirActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 5, 0);
        pFiles.add(jbtBrowseDir, gridBagConstraints);

        jcoSignalSource.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "WAVE file", "Audio IN" }));
        jcoSignalSource.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                onSignalSourceChanged(evt);
            }
        });
        pInputParams.add(jcoSignalSource);

        jlbSourceChannel.setText("Channel:");
        pInputParams.add(jlbSourceChannel);

        jcoSourceChannel.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Mono", "Left", "Right" }));
        pInputParams.add(jcoSourceChannel);

        jlbSampleRate.setText("Rate:");
        pInputParams.add(jlbSampleRate);

        jcoSampleRate.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "44100", "48000", "96000" }));
        pInputParams.add(jcoSampleRate);

        jlbBits.setText("Bits:");
        pInputParams.add(jlbBits);

        jcoBitsPerSample.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "8", "16" }));
        pInputParams.add(jcoBitsPerSample);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        pFiles.add(pInputParams, gridBagConstraints);

        pAttachDetach.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.CENTER, 5, 0));

        jbtAttach.setMnemonic('a');
        jbtAttach.setText("Attach decoder");
        jbtAttach.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                on_attachWaveFile(evt);
            }
        });
        pAttachDetach.add(jbtAttach);

        jbtDetach.setMnemonic('d');
        jbtDetach.setText("Detach decoder");
        jbtDetach.setEnabled(false);
        jbtDetach.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtDetachActionPerformed(evt);
            }
        });
        pAttachDetach.add(jbtDetach);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 0.5;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 4, 0);
        pFiles.add(pAttachDetach, gridBagConstraints);

        jlbSignalSource.setText("Signal source:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pFiles.add(jlbSignalSource, gridBagConstraints);

        getContentPane().add(pFiles, java.awt.BorderLayout.NORTH);

        pDecoding.setLayout(new java.awt.GridBagLayout());

        pNav.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Navigation"));
        pNav.setLayout(new java.awt.GridBagLayout());

        jslNavigation.setValue(0);
        jslNavigation.setEnabled(false);
        jslNavigation.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                on_sliderMoved(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 5);
        pNav.add(jslNavigation, gridBagConstraints);

        jtfSample.setColumns(11);
        jtfSample.setFont(new java.awt.Font("Monospaced", 0, 11)); // NOI18N
        jtfSample.setEnabled(false);
        jtfSample.setMinimumSize(new java.awt.Dimension(32, 18));
        jtfSample.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfSampleActionPerformed(evt);
            }
        });
        pNav.add(jtfSample, new java.awt.GridBagConstraints());

        jbtJump.setMnemonic('j');
        jbtJump.setText("Jump");
        jbtJump.setEnabled(false);
        jbtJump.setMargin(new java.awt.Insets(2, 2, 2, 2));
        jbtJump.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtJumpActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.insets = new java.awt.Insets(0, 5, 0, 0);
        pNav.add(jbtJump, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        pDecoding.add(pNav, gridBagConstraints);

        pDeco.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Decoding"));
        pDeco.setLayout(new java.awt.GridBagLayout());

        jlbDecoder.setText("Decoder:");
        jlbDecoder.setEnabled(false);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 4, 0, 3);
        pDeco.add(jlbDecoder, gridBagConstraints);

        jcoDecoders.setMaximumRowCount(10);
        jcoDecoders.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Turbo 2000", "Turbo 2000 - Kilobyte Blocks", "Universal Turbo", "Turbo Tape", "KSO Turbo 2000", "Turbo Blizzard", "Turbo ROM", "Atari Super Turbo", "Hard Turbo", "Lower Silesian Turbo 2000" }));
        jcoDecoders.setEnabled(false);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 3, 0, 3);
        pDeco.add(jcoDecoders, gridBagConstraints);

        jPanel2.setLayout(new javax.swing.BoxLayout(jPanel2, javax.swing.BoxLayout.X_AXIS));

        jbtDecode.setMnemonic('f');
        jbtDecode.setText("Decode one file");
        jbtDecode.setEnabled(false);
        jbtDecode.setMargin(new java.awt.Insets(2, 2, 2, 2));
        jbtDecode.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtDecodeActionPerformed(evt);
            }
        });
        jPanel2.add(jbtDecode);
        jPanel2.add(filler1);

        jbtDecodeMultiple.setMnemonic('e');
        jbtDecodeMultiple.setText("Decode until EOF");
        jbtDecodeMultiple.setEnabled(false);
        jbtDecodeMultiple.setMargin(new java.awt.Insets(2, 2, 2, 2));
        jbtDecodeMultiple.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtDecodeMultipleActionPerformed(evt);
            }
        });
        jPanel2.add(jbtDecodeMultiple);
        jPanel2.add(filler2);

        jbtStop.setMnemonic('s');
        jbtStop.setText("STOP");
        jbtStop.setToolTipText("Stop decoding (SHIFT for emergency stop) ");
        jbtStop.setEnabled(false);
        jbtStop.setMargin(new java.awt.Insets(2, 2, 2, 2));
        jbtStop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtStopActionPerformed(evt);
            }
        });
        jPanel2.add(jbtStop);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(4, 4, 0, 0);
        pDeco.add(jPanel2, gridBagConstraints);

        jcbMonitorMode.setMnemonic('w');
        jcbMonitorMode.setText("Decode raw blocks");
        jcbMonitorMode.setToolTipText("");
        jcbMonitorMode.setBorder(null);
        jcbMonitorMode.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        pDeco.add(jcbMonitorMode, new java.awt.GridBagConstraints());

        jlbImpulse.setFont(new java.awt.Font("Monospaced", 1, 14)); // NOI18N
        jlbImpulse.setText(" ");
        jlbImpulse.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        pDeco.add(jlbImpulse, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        pDecoding.add(pDeco, gridBagConstraints);

        pControls.setLayout(new java.awt.BorderLayout());

        pLog.setLayout(new java.awt.BorderLayout());

        jlsMessages.setModel(this.logModel);
        jlsMessages.setCellRenderer(new LogListCellRenderer<DecoderMessage>());
        jScrollPane1.setViewportView(jlsMessages);

        pLog.add(jScrollPane1, java.awt.BorderLayout.CENTER);

        jPanel1.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.CENTER, 5, 2));

        btnClearLog.setMnemonic('l');
        btnClearLog.setText("Clear log");
        btnClearLog.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnClearLogActionPerformed(evt);
            }
        });
        jPanel1.add(btnClearLog);

        jbtCopyToClipboard.setMnemonic('C');
        jbtCopyToClipboard.setText("Copy to clipboard");
        jbtCopyToClipboard.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                onCopyToClipBoard(evt);
            }
        });
        jPanel1.add(jbtCopyToClipboard);

        pLog.add(jPanel1, java.awt.BorderLayout.SOUTH);

        jTabbedPane1.addTab("Log", pLog);

        jspGeneralSettings.setPreferredSize(new java.awt.Dimension(411, 320));

        pGeneralSettingsCover.setLayout(new java.awt.GridBagLayout());

        pGeneralSettings.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "General"));
        pGeneralSettings.setLayout(new java.awt.GridBagLayout());

        jcbPrependSampleNumber.setText("Prepend sample numbers to output file names");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pGeneralSettings.add(jcbPrependSampleNumber, gridBagConstraints);

        jcbIgnoreBadChecksums.setText("Ignore bad checksums");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pGeneralSettings.add(jcbIgnoreBadChecksums, gridBagConstraints);

        jcbPreferAdaptiveTransferSpeedDetection.setText("Prefer adaptive transfer speed detection");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pGeneralSettings.add(jcbPreferAdaptiveTransferSpeedDetection, gridBagConstraints);

        jcbVerboseMessages.setText("Verbose messages");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pGeneralSettings.add(jcbVerboseMessages, gridBagConstraints);

        jLabel1.setText("Log font size:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(4, 4, 0, 0);
        pGeneralSettings.add(jLabel1, gridBagConstraints);

        jcbFontSize.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Normal", "Medium", "Large", "Extra large" }));
        jcbFontSize.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                onFontChange(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(4, 4, 0, 0);
        pGeneralSettings.add(jcbFontSize, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
        pGeneralSettingsCover.add(pGeneralSettings, gridBagConstraints);

        pMonitorModeSettings.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Monitor mode"));
        pMonitorModeSettings.setLayout(new java.awt.GridBagLayout());

        jcbMonitorSaveAllBytes.setText("Save all bytes of the decoded blocks");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pMonitorModeSettings.add(jcbMonitorSaveAllBytes, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
        pGeneralSettingsCover.add(pMonitorModeSettings, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        pGeneralSettingsCover.add(filler3, gridBagConstraints);

        pDSP.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "DSP"));
        pDSP.setLayout(new java.awt.GridBagLayout());

        jcbBlockDCOffset.setSelected(true);
        jcbBlockDCOffset.setText("Block DC offset");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pDSP.add(jcbBlockDCOffset, gridBagConstraints);

        jspSchmitt.setModel(new javax.swing.SpinnerNumberModel(0, 0, 16383, 1));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pDSP.add(jspSchmitt, gridBagConstraints);

        jLabel3.setText("Schmitt trigger hysteresis:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pDSP.add(jLabel3, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
        pGeneralSettingsCover.add(pDSP, gridBagConstraints);

        jspGeneralSettings.setViewportView(pGeneralSettingsCover);

        jTabbedPane1.addTab("General settings", jspGeneralSettings);

        pOtherSettingsCover.setLayout(new java.awt.GridBagLayout());
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        pOtherSettingsCover.add(filler4, gridBagConstraints);

        pTurbo2000SuperTurbo.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Turbo 2000 and Super Turbo"));
        pTurbo2000SuperTurbo.setLayout(new java.awt.GridBagLayout());

        jcbCsTurboSaveHeaderToExtraFile.setText("Save header to extra file");
        jcbCsTurboSaveHeaderToExtraFile.setToolTipText("Create extra file that holds full header data");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pTurbo2000SuperTurbo.add(jcbCsTurboSaveHeaderToExtraFile, gridBagConstraints);

        jcbCsTurboAlwaysSaveAsBinaryFile.setText("Always save as binary file");
        jcbCsTurboAlwaysSaveAsBinaryFile.setToolTipText("Save the decoded file as a binary file regardless the file type in the header");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        pTurbo2000SuperTurbo.add(jcbCsTurboAlwaysSaveAsBinaryFile, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
        pOtherSettingsCover.add(pTurbo2000SuperTurbo, gridBagConstraints);

        pASTSettings.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Atari Super Turbo"));
        pASTSettings.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT, 4, 0));

        jlbASTFormat.setLabelFor(jcoASTFormat);
        jlbASTFormat.setText("File format:");
        pASTSettings.add(jlbASTFormat);

        jcoASTFormat.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "AST" }));
        jcoASTFormat.setAlignmentX(0.0F);
        pASTSettings.add(jcoASTFormat);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
        pOtherSettingsCover.add(pASTSettings, gridBagConstraints);

        pLowerSilesiaTurbo2000Settings.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Lower Silesian Turbo 2000"));
        pLowerSilesiaTurbo2000Settings.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT, 4, 0));

        jlbLowerSilesiaTurbo2000Format.setLabelFor(jcoASTFormat);
        jlbLowerSilesiaTurbo2000Format.setText("File format:");
        pLowerSilesiaTurbo2000Settings.add(jlbLowerSilesiaTurbo2000Format);

        jcoLowerSilesiaTurbo2000Format.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Auto Turbo", "Unknown Exterminator unprotected", "Unknown Exterminator protected", "Funny Copy 1.0 protected" }));
        jcoLowerSilesiaTurbo2000Format.setAlignmentX(0.0F);
        pLowerSilesiaTurbo2000Settings.add(jcoLowerSilesiaTurbo2000Format);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
        pOtherSettingsCover.add(pLowerSilesiaTurbo2000Settings, gridBagConstraints);

        pKSOTurbo2000Settings.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "KSO Turbo 2000"));
        pKSOTurbo2000Settings.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT, 4, 0));

        jlbKSOTurbo2000Format.setLabelFor(jcoASTFormat);
        jlbKSOTurbo2000Format.setText("File format:");
        pKSOTurbo2000Settings.add(jlbKSOTurbo2000Format);

        jcoKSOTurbo2000Format.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Natural file format", "File with a loader" }));
        jcoKSOTurbo2000Format.setAlignmentX(0.0F);
        pKSOTurbo2000Settings.add(jcoKSOTurbo2000Format);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
        pOtherSettingsCover.add(pKSOTurbo2000Settings, gridBagConstraints);

        pTurboROMSettings.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Turbo ROM"));
        pTurboROMSettings.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT, 4, 0));

        jlbTurboROMFormat.setLabelFor(jcoASTFormat);
        jlbTurboROMFormat.setText("File format:");
        pTurboROMSettings.add(jlbTurboROMFormat);

        jcoTurboROMFormat.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Binary file", "BASIC" }));
        jcoTurboROMFormat.setAlignmentX(0.0F);
        pTurboROMSettings.add(jcoTurboROMFormat);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
        pOtherSettingsCover.add(pTurboROMSettings, gridBagConstraints);

        jspOtherSettings.setViewportView(pOtherSettingsCover);

        jTabbedPane1.addTab("Other settings", jspOtherSettings);

        pControls.add(jTabbedPane1, java.awt.BorderLayout.CENTER);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(8, 0, 0, 0);
        pDecoding.add(pControls, gridBagConstraints);

        getContentPane().add(pDecoding, java.awt.BorderLayout.CENTER);

        jmFile.setMnemonic('F');
        jmFile.setText("File");

        jmiExit.setMnemonic('x');
        jmiExit.setText("Exit");
        jmiExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmiExitActionPerformed(evt);
            }
        });
        jmFile.add(jmiExit);

        jMenuBar1.add(jmFile);

        jmHelp.setMnemonic('H');
        jmHelp.setText("Help");

        jmiAbout.setText("About...");
        jmiAbout.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmiAboutActionPerformed(evt);
            }
        });
        jmHelp.add(jmiAbout);

        jMenuBar1.add(jmHelp);

        setJMenuBar(jMenuBar1);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void attachDecoder(String source, String channel) {

        /*Close open decoder if any*/
        if (decoder != null) {
            try {
                decoder.close(null);
            } catch (Exception e1) {
                e1.printStackTrace();
            }
        }


        /*Initialize either decoder*/
        try {
            /*Audio decoder*/
            if (!(source.equals("WAVE file"))) {

                /*Initialize decoder*/
                decoder = audioDecoder;
                decoder.init("", Integer.parseInt((String)jcoSampleRate.getSelectedItem()),jcoSourceChannel.getSelectedIndex(),Integer.parseInt((String)jcoBitsPerSample.getSelectedItem()),jcbBlockDCOffset.isSelected(),(Integer)jspSchmitt.getValue(),this);
                
            } /*Wave file decoder*/ else {
                decoder = waveDecoder;
                decoder.init(jtfWaveFile.getText().trim(), 0,jcoSourceChannel.getSelectedIndex(),0,jcbBlockDCOffset.isSelected(),(Integer)jspSchmitt.getValue(),this);
            }
        } /*Failure - close and issue message*/ catch (Exception e) {
            try {
                decoder.close(null);
            } catch (Exception e2) {
                e2.printStackTrace();
            }
            setAttachDependentControlsEnabled(false);
            e.printStackTrace();
            JOptionPane.showMessageDialog(this, Utils.getTitledExceptionMessage("Unable to initialize decoder", e));
            return;
        }

        /*Prepare GUI elements*/
        long siz = decoder.getTotalSamples();
        jtfSample.setText("0");
        jslNavigation.setMinimum(0);
        jslNavigation.setMaximum((int) siz);
        jslNavigation.setValue(0);
        setAttachDependentControlsEnabled(true);

    }

    private void detachDecoder() {

        /*Close the decoder*/
        try {
            decoder.close(null);
        } catch (Exception e) {
            e.printStackTrace();
        }

        /*Prepare GUI elements*/
        setAttachDependentControlsEnabled(false);
    }

private void on_attachWaveFile(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_on_attachWaveFile

    attachDecoder((String) jcoSignalSource.getSelectedItem(), (String) jcoSourceChannel.getSelectedItem());

}//GEN-LAST:event_on_attachWaveFile

private void on_sliderMoved(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_on_sliderMoved
    jtfSample.setText(Integer.toString(jslNavigation.getValue()));

}//GEN-LAST:event_on_sliderMoved

private void jbtDecodeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtDecodeActionPerformed
    performDecoding(false);
}//GEN-LAST:event_jbtDecodeActionPerformed

private void btnClearLogActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnClearLogActionPerformed
    logModel.clearAllMessages();
}//GEN-LAST:event_btnClearLogActionPerformed

private void jbtJumpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtJumpActionPerformed

    int loc;
    try { 
        loc = Integer.parseInt(jtfSample.getText().trim());
    } catch (NumberFormatException e) {
        /*Nothing to do*/
        return;
    }
    jslNavigation.setValue(loc);
}//GEN-LAST:event_jbtJumpActionPerformed

private void jbtBrowseWaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtBrowseWaveActionPerformed
    if (fcDecodeInput.showOpenDialog(this) == JFileChooser.CANCEL_OPTION) {
        return;
    }
    File f = fcDecodeInput.getSelectedFile();
    if (f != null) {
        jtfWaveFile.setText(f.getAbsolutePath());
    }
}//GEN-LAST:event_jbtBrowseWaveActionPerformed

private void jbtBrowseDirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtBrowseDirActionPerformed
    if (fcDecodeOutput.showSaveDialog(this) == JFileChooser.CANCEL_OPTION) {
        return;
    }
    File f = fcDecodeOutput.getSelectedFile();
    if (f != null) {
        jtfOutDir.setText(f.getAbsolutePath());
    }
}//GEN-LAST:event_jbtBrowseDirActionPerformed

private void jbtDecodeMultipleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtDecodeMultipleActionPerformed
    performDecoding(true);
}//GEN-LAST:event_jbtDecodeMultipleActionPerformed

private void on_close(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_on_close

    if (decodingThread != null && decodingThread.isAlive()) {
        handleStop(null);
    }

    TurboDecoder.getInstance().getDlm().setDecoderTransientFrameVisible(false);
    TurboDecoder.getInstance().getDlm().saveBounds();
    
}//GEN-LAST:event_on_close

private void jbtDetachActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtDetachActionPerformed
    detachDecoder();
}//GEN-LAST:event_jbtDetachActionPerformed

private void jbtStopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtStopActionPerformed

    handleStop(evt);

}//GEN-LAST:event_jbtStopActionPerformed

private void jtfSampleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfSampleActionPerformed
    jbtJumpActionPerformed(evt);
}//GEN-LAST:event_jtfSampleActionPerformed

    private void onSignalSourceChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_onSignalSourceChanged

        String s = (String) evt.getItem();

        if (s.equalsIgnoreCase("WAVE file")) {
            if (evt.getStateChange() == ItemEvent.SELECTED) {
                setWaveInputSourceComponentsEnabled(true);
            } else {
                setWaveInputSourceComponentsEnabled(false);
            }
        }

    }//GEN-LAST:event_onSignalSourceChanged

    private void onCopyToClipBoard(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_onCopyToClipBoard

        JTextArea tempArea = new JTextArea();
        String ln = System.getProperty("line.separator");

        ArrayList<DecoderMessage> messages = logModel.getMessages();
        Iterator<DecoderMessage> it = messages.iterator();

        tempArea.setText("");
        while (it.hasNext()) {
            tempArea.append(it.next().getMessage());
            tempArea.append(ln);
        }

        tempArea.selectAll();
        tempArea.copy();

    }//GEN-LAST:event_onCopyToClipBoard

    private void onFontChange(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_onFontChange
        if (!(evt.getStateChange() == ItemEvent.SELECTED)) {
            return;
        }

        int index = jcbFontSize.getSelectedIndex();
        ((Component) jlsMessages.getCellRenderer()).setFont(logFonts[index]);

    }//GEN-LAST:event_onFontChange

    private void jmiAboutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmiAboutActionPerformed
       String s = TurboDecoder.getInstance().getProgramInfoString();
       JOptionPane.showMessageDialog(this, s, "About", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_jmiAboutActionPerformed

    private void jmiExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmiExitActionPerformed
        on_close(null);
    }//GEN-LAST:event_jmiExitActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new DecoderFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnClearLog;
    private javax.swing.JFileChooser fcDecodeInput;
    private javax.swing.JFileChooser fcDecodeOutput;
    private javax.swing.Box.Filler filler1;
    private javax.swing.Box.Filler filler2;
    private javax.swing.Box.Filler filler3;
    private javax.swing.Box.Filler filler4;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JButton jbtAttach;
    private javax.swing.JButton jbtBrowseDir;
    private javax.swing.JButton jbtBrowseWave;
    private javax.swing.JButton jbtCopyToClipboard;
    private javax.swing.JButton jbtDecode;
    private javax.swing.JButton jbtDecodeMultiple;
    private javax.swing.JButton jbtDetach;
    private javax.swing.JButton jbtJump;
    private javax.swing.JButton jbtStop;
    private javax.swing.JCheckBox jcbBlockDCOffset;
    private javax.swing.JCheckBox jcbCsTurboAlwaysSaveAsBinaryFile;
    private javax.swing.JCheckBox jcbCsTurboSaveHeaderToExtraFile;
    private javax.swing.JComboBox<String> jcbFontSize;
    private javax.swing.JCheckBox jcbIgnoreBadChecksums;
    private javax.swing.JCheckBox jcbMonitorMode;
    private javax.swing.JCheckBox jcbMonitorSaveAllBytes;
    private javax.swing.JCheckBox jcbPreferAdaptiveTransferSpeedDetection;
    private javax.swing.JCheckBox jcbPrependSampleNumber;
    private javax.swing.JCheckBox jcbVerboseMessages;
    private javax.swing.JComboBox<String> jcoASTFormat;
    private javax.swing.JComboBox<String> jcoBitsPerSample;
    private javax.swing.JComboBox<String> jcoDecoders;
    private javax.swing.JComboBox<String> jcoKSOTurbo2000Format;
    private javax.swing.JComboBox<String> jcoLowerSilesiaTurbo2000Format;
    private javax.swing.JComboBox<String> jcoSampleRate;
    private javax.swing.JComboBox<String> jcoSignalSource;
    private javax.swing.JComboBox<String> jcoSourceChannel;
    private javax.swing.JComboBox<String> jcoTurboROMFormat;
    private javax.swing.JLabel jlbASTFormat;
    private javax.swing.JLabel jlbBits;
    private javax.swing.JLabel jlbDecoder;
    private javax.swing.JLabel jlbImpulse;
    private javax.swing.JLabel jlbKSOTurbo2000Format;
    private javax.swing.JLabel jlbLowerSilesiaTurbo2000Format;
    private javax.swing.JLabel jlbSampleRate;
    private javax.swing.JLabel jlbSignalSource;
    private javax.swing.JLabel jlbSourceChannel;
    private javax.swing.JLabel jlbTurboROMFormat;
    private javax.swing.JLabel jlbWave;
    private javax.swing.JList<DecoderMessage> jlsMessages;
    private javax.swing.JMenu jmFile;
    private javax.swing.JMenu jmHelp;
    private javax.swing.JMenuItem jmiAbout;
    private javax.swing.JMenuItem jmiExit;
    private javax.swing.JSlider jslNavigation;
    private javax.swing.JScrollPane jspGeneralSettings;
    private javax.swing.JScrollPane jspOtherSettings;
    private javax.swing.JSpinner jspSchmitt;
    private javax.swing.JTextField jtfOutDir;
    private javax.swing.JTextField jtfSample;
    private javax.swing.JTextField jtfWaveFile;
    private javax.swing.JPanel pASTSettings;
    private javax.swing.JPanel pAttachDetach;
    private javax.swing.JPanel pControls;
    private javax.swing.JPanel pDSP;
    private javax.swing.JPanel pDeco;
    private javax.swing.JPanel pDecoding;
    private javax.swing.JPanel pFiles;
    private javax.swing.JPanel pGeneralSettings;
    private javax.swing.JPanel pGeneralSettingsCover;
    private javax.swing.JPanel pInputParams;
    private javax.swing.JPanel pKSOTurbo2000Settings;
    private javax.swing.JPanel pLog;
    private javax.swing.JPanel pLowerSilesiaTurbo2000Settings;
    private javax.swing.JPanel pMonitorModeSettings;
    private javax.swing.JPanel pNav;
    private javax.swing.JPanel pOtherSettingsCover;
    private javax.swing.JPanel pTurbo2000SuperTurbo;
    private javax.swing.JPanel pTurboROMSettings;
    // End of variables declaration//GEN-END:variables

    /**
     *
     * @param automated
     */
    public void performDecoding(boolean automated) {

        final boolean _automat;
        final FileDecoder _decoder;
        final String _outdir;
        final DecoderConfig _prm;

        /*Choose Turbo type*/
        int turboType = jcoDecoders.getSelectedIndex();
        if (turboType < 0) {
            return;
        }

        /*Set sample according to navigation slider*/
        try {
            decoder.setCurrentSample(jslNavigation.getValue());
        } catch (Exception e) {
            e.printStackTrace();
        }

        /*What turbo system?*/
        if (jcbMonitorMode.isSelected()) {
            _decoder = new TurboMonitorDecoder(turboType);
        } else {

            switch (turboType) {
                case FileDecoder.CS_TURBO_2000: {
                    _decoder = new Turbo2000FileDecoder();
                    break;
                }
                case FileDecoder.CS_TURBO_2000_KB: {
                    _decoder = new KBlockFileDecoder();
                    break;
                }
                case FileDecoder.CS_SUPER_TURBO: {
                    _decoder = new UniversalTurboFileDecoder();
                    break;
                }

                case FileDecoder.CS_TURBO_TAPE: {
                    _decoder = new TurboTapeDecoder();
                    break;
                }

                case FileDecoder.PL_KSO_TURBO_2000: {
                    _decoder = new KSOTurbo2000FileDecoder();
                    break;
                }
                case FileDecoder.PL_TURBO_BLIZZARD: {
                    _decoder = new TurboBlizzardFileDecoder();
                    break;
                }
                case FileDecoder.PL_TURBO_ROM: {
                    _decoder = new TurboRomFileDecoder();
                    break;
                }
                case FileDecoder.PL_ATARI_SUPER_TURBO: {
                    _decoder = new ASTFileDecoder();
                    break;
                }

                case FileDecoder.PL_HARD_TURBO: {
                    _decoder = new HardTurboFileDecoder();
                    break;
                }
                case FileDecoder.PL_LOWER_SILESIA_TURBO_2000: {
                    _decoder = new LowerSilesianTurbo2000FileDecoder();
                    break;
                }

                default: {
                    _decoder = null;
                }
            }
        }

        /*Try to set parameters of the decoder. Always get a copy for given
         decoder invocation*/
        _prm = getConfigFromDialog();

        _outdir = jtfOutDir.getText().trim();
        _automat = automated;

        /*Run the thread*/
        decodingThread = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (decoderSyncronizer) {
                    runFileDecoder(_decoder, _automat, _outdir, _prm);
                }
            }
        });

        decodingThread.start();

    }

    void setAttachDependentControlsEnabled(boolean b) {

        /*Decoder type independent elements to be enabled*/
        jbtDecode.setEnabled(b);
        jslNavigation.setEnabled(b);
        jtfSample.setEnabled(b);
        jbtJump.setEnabled(b);
        jcoDecoders.setEnabled(b);
        jbtDecodeMultiple.setEnabled(b);
        jlbDecoder.setEnabled(b);
        jbtDetach.setEnabled(b);

        /*Decoder type independent elements to be disabled*/
        b = !b;
        jtfWaveFile.setEnabled(b);
        jbtBrowseWave.setEnabled(b);
        jlbWave.setEnabled(b);
        jbtAttach.setEnabled(b);
        jcoSourceChannel.setEnabled(b);
        jlbSignalSource.setEnabled(b);
        jcoSignalSource.setEnabled(b);
        jlbSourceChannel.setEnabled(b);
        jcoSampleRate.setEnabled(b);
        jlbSampleRate.setEnabled(b);
        jlbBits.setEnabled(b);
        jcoBitsPerSample.setEnabled(b);

        handleComponentDependencies();

    }

    private DecoderConfig getConfigFromDialog() {
        DecoderConfig retVal = new DecoderConfig();
        flushAll(retVal);
        return retVal;
    }

    void flushGenConfig(DecoderConfig d) {
        d.genIgnoreBadSum = jcbIgnoreBadChecksums.isSelected();
        d.genPreferAdaptiveSpeedDetection = jcbPreferAdaptiveTransferSpeedDetection.isSelected();
        d.genPrependSampleNumber = jcbPrependSampleNumber.isSelected();
        d.genVerboseMessages = jcbVerboseMessages.isSelected();
    }

    void flushMonitorModeConfig(DecoderConfig d) {
        d.monitorSaveAllBytes = jcbMonitorSaveAllBytes.isSelected();
    }
    
    void flushDSPCofig(DecoderConfig d) {
        d.dspBlockDCOffset=jcbBlockDCOffset.isSelected();
    }

    void flushTurbo2000AndSuperTurboConfig(DecoderConfig d) {
        d.csTurboSaveHeaderToExtraFile = jcbCsTurboSaveHeaderToExtraFile.isSelected();
        d.csTurboAlwaysSaveAsBinary = jcbCsTurboAlwaysSaveAsBinaryFile.isSelected();
    }

    void flushTurboROMConfig(DecoderConfig d) {
        d.turboROMFileFormat = jcoTurboROMFormat.getSelectedIndex();
    }

    void flushKSOTurbo2000Config(DecoderConfig d) {
        d.ksoTurbo2000FileFormat = jcoKSOTurbo2000Format.getSelectedIndex();
    }

    void flushLowerSilesiaTurbo2000Config(DecoderConfig d) {
        d.lowerSilesianTurbo2000FileFormat = jcoLowerSilesiaTurbo2000Format.getSelectedIndex();
    }

    private void flushHardTurboConfig(DecoderConfig d) {
    }

    void suckGenConfig(DecoderConfig d) {
        jcbIgnoreBadChecksums.setSelected(d.genIgnoreBadSum);
        jcbPreferAdaptiveTransferSpeedDetection.setSelected(d.genPreferAdaptiveSpeedDetection);
        jcbPrependSampleNumber.setSelected(d.genPrependSampleNumber);
        jcbVerboseMessages.setSelected(d.genVerboseMessages);
    }

    void suckMonitorModeConfig(DecoderConfig d) {
        jcbMonitorSaveAllBytes.setSelected(d.monitorSaveAllBytes);
    }
    
    private void suckDSPConfig(DecoderConfig d) {
        jcbBlockDCOffset.setSelected(d.dspBlockDCOffset);
    }

    void suckTurbo2000AndSuperTurboConfig(DecoderConfig d) {
        jcbCsTurboSaveHeaderToExtraFile.setSelected(d.csTurboSaveHeaderToExtraFile);
        jcbCsTurboAlwaysSaveAsBinaryFile.setSelected(d.csTurboAlwaysSaveAsBinary);

    }

    void suckTurboROMConfig(DecoderConfig d) {
        jcoTurboROMFormat.setSelectedIndex(d.turboROMFileFormat);
    }

    void suckKSOTurbo2000Config(DecoderConfig d) {
        jcoKSOTurbo2000Format.setSelectedIndex((d.ksoTurbo2000FileFormat));
    }

    void suckLowerSilesiaTurbo2000Config(DecoderConfig d) {
        jcoLowerSilesiaTurbo2000Format.setSelectedIndex(d.lowerSilesianTurbo2000FileFormat);

    }

    private void suckHardTurboConfig(DecoderConfig d) {

    }

    void flushAll(DecoderConfig d) {
        flushGenConfig(d);
        flushMonitorModeConfig(d);
        flushDSPCofig(d);
        flushTurbo2000AndSuperTurboConfig(d);
        flushTurboROMConfig(d);
        flushLowerSilesiaTurbo2000Config(d);
        flushHardTurboConfig(d);
        flushKSOTurbo2000Config(d);
    }

    void suckAll(DecoderConfig d) {
        suckGenConfig(d);
        suckMonitorModeConfig(d);
        suckDSPConfig(d);
        suckTurbo2000AndSuperTurboConfig(d);
        suckTurboROMConfig(d);
        suckLowerSilesiaTurbo2000Config(d);
        suckHardTurboConfig(d);
        suckKSOTurbo2000Config(d);
    }

    private void restoreDefaults() {
        DecoderConfig d = new DecoderConfig();
        flushAll(d);
    }

    /**
     *
     */
    public void updateFileDialogUI() {
        SwingUtilities.updateComponentTreeUI(fcDecodeInput);
        SwingUtilities.updateComponentTreeUI(fcDecodeOutput);
    }

    void runFileDecoder(FileDecoder d, boolean multiple, String outdir, DecoderConfig config) {

        boolean cont;

        /*Disable components*/
        ParallelGUIUpdater.setComponentsEnabled(decodingInvocationComponents, false);
        ParallelGUIUpdater.setComponentsEnabled(decodingCancelationComponents, true);

        /*Single*/
        if (multiple == false) {
            try {
                d.decodeFile(outdir, this, decoder, config);
                ParallelGUIUpdater.updateSlider(jslNavigation, (int) decoder.getCurrentSample());
            } catch (Exception e) {
                e.printStackTrace();
            }
        } /*Multiple*/ else {
            try {
                do {
                    cont = d.decodeFile(outdir, this, decoder, config);
                    ParallelGUIUpdater.updateSlider(jslNavigation, (int) decoder.getCurrentSample());
                } while (cont == true);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        /*Enable components*/
        ParallelGUIUpdater.setComponentsEnabled(decodingInvocationComponents, true);
        ParallelGUIUpdater.setComponentsEnabled(decodingCancelationComponents, false);

    }

    /**
     * Handle stopping of the decoder
     */
    private void handleStop(java.awt.event.ActionEvent evt) {

        /*Window is closed, only stop*/
        if (evt == null) {
            decoder.requestStop(false);
            return;
        }

        /*Stop button is pressed - WAVE*/
        if (decoder instanceof WavePulseDecoder) {
            decoder.requestStop(false);
        } /*Stop button for Audio input - SHIFT means emergency STOP*/ else {
            boolean b = false;
            if ((evt.getModifiers() & ActionEvent.SHIFT_MASK) != 0) {
                b = true;
            }
            decoder.requestStop(b);

            /*Instruct user to detach the decoder*/
            if (b == true) {
                JOptionPane.showMessageDialog(this, "<HTML>Emergency stop of the decoding was requested.<BR>Decoder must be <U>detached</U> before it can be used again!", "Emergency stop", JOptionPane.WARNING_MESSAGE);
            }
        }

    }

   
    
    private static class PersistentData implements Serializable {
        Rectangle frameBounds;
        int frameExtendedState;
        String fcDecodeInputPath;
        String fcDecodeOutputPath;
        String tfOutDir;
        String tfWaveFile;
        
        int signalSourceIndex;
        int sourceChannelIndex;
        int decoderIndex;
        int sampleRateIndex;
        boolean monitorMode;
        int numBitsIndex;
        int fontSizeIndex;
        DecoderConfig decoderConfig;
        
    }

    /**
     *
     * @return
     */
    @Override
    public PersistentData getPersistenceData() {
        
        PersistentData pd = new PersistentData();

        /*Bounds and frame state*/
        pd.frameBounds = getBounds();
        pd.frameExtendedState = getExtendedState();

        /*File chooser and text field directories*/
        pd.fcDecodeInputPath = fcDecodeInput.getCurrentDirectory().getAbsolutePath();
        pd.fcDecodeOutputPath = fcDecodeOutput.getCurrentDirectory().getAbsolutePath();

        pd.tfOutDir = jtfOutDir.getText();
        pd.tfWaveFile = jtfWaveFile.getText();

        /*Decoder configuration*/
        DecoderConfig d = new DecoderConfig();
        flushAll(d);
        pd.decoderConfig=d;

        /*Pulse decoder and file decoder*/
        pd.signalSourceIndex = jcoSignalSource.getSelectedIndex();
        pd.sourceChannelIndex = jcoSourceChannel.getSelectedIndex();
        pd.decoderIndex = jcoDecoders.getSelectedIndex();
        pd.sampleRateIndex = jcoSampleRate.getSelectedIndex();
        pd.monitorMode = jcbMonitorMode.isSelected();
        pd.numBitsIndex = jcoBitsPerSample.getSelectedIndex();
        pd.fontSizeIndex = jcbFontSize.getSelectedIndex();

        return pd;

    }

    
    
    
    /**
     *
     * @param dta Persistence data
     * @throws Exception
     */
    @Override
    public void setPersistenceData(Object dta) throws Exception {
        
        PersistentData  pd  = (PersistentData)dta;
        
        /*Bounds and frame state*/
        setBounds(pd.frameBounds);
        setExtendedState(pd.frameExtendedState);

        /*File chooser and text field directories*/
        fcDecodeInput.setCurrentDirectory(new File(pd.fcDecodeInputPath));
        fcDecodeOutput.setCurrentDirectory(new File(pd.fcDecodeOutputPath));

        jtfOutDir.setText(pd.tfOutDir);
        jtfWaveFile.setText(pd.tfWaveFile);

        /*Pulse decoder and file decoder*/
        jcoSignalSource.setSelectedIndex(pd.signalSourceIndex);
        jcoSourceChannel.setSelectedIndex(pd.sourceChannelIndex);
        jcoDecoders.setSelectedIndex(pd.decoderIndex);
        jcoSampleRate.setSelectedIndex(pd.sampleRateIndex);
        jcbMonitorMode.setSelected(pd.monitorMode);
        jcoBitsPerSample.setSelectedIndex(pd.numBitsIndex);
        jcbFontSize.setSelectedIndex(pd.fontSizeIndex);

        /*Decoders' configuration - volatile, so the last one*/
        DecoderConfig d = pd.decoderConfig;
        suckAll(d);

    }

    /**
     *
     * @return
     */
    @Override
    public String getPersistenceId() {
        return getClass().getName();
    }

    /**
     *
     */
    @Override
    public void setPersistenceDefaults() {
        DecoderConfig d = new DecoderConfig();
        suckAll(d);
        jcoSignalSource.setSelectedIndex(0);
        jcoDecoders.setSelectedIndex(0);
        jcoBitsPerSample.setSelectedIndex(0);
        pack();
        DialogManager.centerContainer(this);

    }

    private void handleComponentDependencies() {

        if (!jcoSignalSource.isEnabled()) {
            return;
        }

        String s = (String) jcoSignalSource.getSelectedItem();
        if (s.equalsIgnoreCase("WAVE file")) {
            setWaveInputSourceComponentsEnabled(true);
        } else {
            setWaveInputSourceComponentsEnabled(false);
        }
    }

    private void setWaveInputSourceComponentsEnabled(boolean b) {
        jtfWaveFile.setEnabled(b);
        jbtBrowseWave.setEnabled(b);
        jlbWave.setEnabled(b);
        jcoSampleRate.setEnabled(!b);
        jlbSampleRate.setEnabled(!b);
        jlbBits.setEnabled(!b);
        jcoBitsPerSample.setEnabled(!b);
    }

    /**
     *
     * @param fromExtThread
     */
    @Override
    public void impulse(boolean fromExtThread) {

        if (fromExtThread == false) {
            impulsePhase = (impulsePhase + 1) % 4;
            jlbImpulse.setText(impulseStrings[impulsePhase]);
        } else {
            SwingUtilities.invokeLater(new Runnable() {
                @Override
                public void run() {
                    impulsePhase = (impulsePhase + 1) % 4;
                    jlbImpulse.setText(impulseStrings[impulsePhase]);
                }
            });
        }

    }

    /**
     *
     * @param msg
     * @param fromExternalThread
     */
    @Override
    public void addMessage(DecoderMessage msg, boolean fromExternalThread) {
        final DecoderMessage fmsg = msg;

        if (fromExternalThread == false) {
            logModel.addMessage(fmsg);
        } else {
            try {
                SwingUtilities.invokeAndWait(new Runnable() {
                    @Override
                    public void run() {
                        logModel.addMessage(fmsg);
                    }
                });
            } catch (InterruptedException | InvocationTargetException ie) {
            }
        }
    }

    /**
     *
     * @param fromExternalThread
     */
    @Override
    public void clearAllMessages(boolean fromExternalThread) {
        logModel.clearAllMessages();
    }

    private void initLogModel() {
        logModel = new DecoderLogModel();
    }

    private static class LogListCellRenderer<E> extends JLabel implements ListCellRenderer<DecoderMessage> {

        private final Insets insets = new Insets(2, 2, 2, 2);
        private final Color[] foreColors;
        private final Color[] backColors;

        LogListCellRenderer() {

            super();
            setOpaque(true);
            Font font = new Font(Font.DIALOG_INPUT, Font.PLAIN, 12);
            setFont(font);

            foreColors = new Color[5];
            backColors = new Color[5];

            foreColors[0] = Color.BLACK;
            foreColors[1] = Color.BLACK;
            foreColors[2] = Color.BLACK;
            foreColors[3] = Color.GRAY;
            foreColors[4] = Color.BLACK;

            backColors[0] = Color.GREEN;
            backColors[1] = Color.RED;
            backColors[2] = Color.YELLOW;
            backColors[3] = Color.WHITE;
            backColors[4] = Color.CYAN;

        }

        @Override
        public Component getListCellRendererComponent(JList<? extends DecoderMessage> list, DecoderMessage value, int index, boolean isSelected, boolean cellHasFocus) {

            DecoderMessage msg = (list.getModel().getElementAt(index));

            setText(msg.getMessage());

            if (isSelected == true) {
                Color bg = new Color(list.getSelectionBackground().getRGB());
                Color fg = new Color(list.getSelectionForeground().getRGB());
                setBackground(bg);
                setForeground(fg);
            } else {
                int severity = msg.getSeverity();
                setBackground(backColors[severity]);
                setForeground(foreColors[severity]);
            }

            return this;
        }

        @Override
        public Insets getInsets() {
            return insets;
        }

    }

    /**
     * Initialize fonts for the playlist
     */
    private void initLogFonts() {

        logFonts = new Font[4];
        int size = 12;
        Font normalFont = new Font(Font.MONOSPACED, Font.PLAIN, 12);

        logFonts[LOG_FONT_NORMAL] = normalFont;
        logFonts[LOG_FONT_MEDIUM] = normalFont.deriveFont(((float) (size + 1)));
        logFonts[LOG_FONT_LARGE] = normalFont.deriveFont(((float) (size + 2)));
        logFonts[LOG_FONT_EXTRA_LARGE] = normalFont.deriveFont((float) (size + 4));

    }

}
